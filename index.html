<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>格子ミラー 統合（探索 + サンドボックス）</title>
<style>
  body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;padding:18px}
  .tabs{display:flex;gap:8px;margin-bottom:12px}
  .tab{padding:8px 12px;border:1px solid #ccc;border-bottom:none;border-radius:6px 6px 0 0;cursor:pointer;background:#f4f4f4}
  .tab.active{background:#fff;border-bottom:1px solid #fff;font-weight:bold}
  .panel-wrap{border:1px solid #ccc;border-radius:0 6px 6px 6px;padding:12px;background:#fff}
  .controls{margin-bottom:8px}
  label{margin-right:8px}
  .section{display:none}
  .section.active{display:block}
  /* サンドボックス固有 */
  #boardWrap{display:inline-block;vertical-align:top}
  svg{border:1px solid #ddd;background:#fafafa;display:block}
  .panel{display:inline-block;vertical-align:top;margin-left:14px;min-width:260px}
  .small{font-size:0.9em;color:#444}
  button{margin:4px 6px 4px 0}
  .stat{margin-top:8px;background:#f7f7f7;padding:8px;border-radius:6px;border:1px solid #eee}
  .legend-item{display:flex;align-items:center;margin-bottom:6px}
  .swatch{width:18px;height:12px;margin-right:8px;border-radius:2px}
  .note{font-size:0.85em;color:#666;margin-top:6px}
  /* 探索モード固有 */
  .thumb{display:inline-block;margin:6px;border:1px solid #ccc;padding:6px;cursor:pointer;vertical-align:top}
  .small-muted{font-size:0.85em;color:#666}
  details{margin-top:12px;background:#f9f9f9;border:1px solid #ccc;border-radius:6px;padding:8px}
  details summary{cursor:pointer;font-weight:bold}
</style>
</head>
<body>
  <h2>格子ミラー — 統合（探索モード / サンドボックス）</h2>

  <div class="tabs">
    <div class="tab active" data-target="explorer">探索モード (Explorer)</div>
    <div class="tab" data-target="sandbox">サンドボックス (Sandbox)</div>
  </div>

  <div class="panel-wrap">
    <!-- 探索モード -->
    <div id="explorer" class="section active">
      <details>
        <summary>🔍 探索モード・パラメータの説明</summary>
        <p><b>完全探索：</b> すべての鏡配置を試して canonical 単位で数えます（重い処理）。</p>
        <p><b>近似：</b> ランダム/ハイブリッドでサンプリングして異なる経路数から推定します。</p>
      </details>

      <div class="controls">
        <label>グリッドサイズ: <input id="exp_sizeInput" type="number" min="1" max="10" value="3" /></label>
        <label>入射位置（下から）: <select id="exp_inputSelect"></select></label>
      </div>

      <div class="controls">
        <label>探索モード:
          <select id="exp_modeSelect">
            <option value="standard">標準近似</option>
            <option value="hybrid">改良（長経路優先）</option>
          </select>
        </label>
        <label>サンプル数: <input id="exp_samplesInput" type="number" value="20000" min="1000" step="1000"></label>
        <label>深さ制限: <input id="exp_depthInput" type="number" value="200" min="1" step="1"></label>
        <label><input id="exp_forceExact" type="checkbox"> 強制: 完全探索</label>
        <button id="exp_runBtn">探索開始</button>
        <span id="exp_progress" class="small-muted"></span>
      </div>

      <div class="controls">
        <strong>結果：</strong> <span id="exp_resultSummary">---</span>
      </div>

      <div id="exp_canvasWrap"></div>
      <h3>有効パターン（代表） — クリックで詳細（上限200）</h3>
      <div id="exp_thumbs"></div>
    </div>

    <!-- サンドボックスモード -->
    <div id="sandbox" class="section">
      <div class="controls">
        <label>グリッド N: <input id="sb_sizeInput" type="number" min="1" value="5" style="width:70px"></label>
        <label>シミュレーション:
          <select id="sb_simMode">
            <option value="down">下 → 右</option>
            <option value="left">左 → 上</option>
            <option value="both">両方（同時）</option>
          </select>
        </label>
        <button id="sb_simulateBtn">光を追跡</button>
        <button id="sb_resetBtn">リセット</button>
      </div>

      <div id="sb_mainArea">
        <div id="boardWrap"></div>
        <div class="panel">
          <div class="small"><b>操作</b></div>
          <div class="small">・セルをクリックで鏡を配置／切替。<br>・下辺または左辺の〇をクリックで光線を追加／削除。</div>

          <div class="stat" id="statsBox">
            <div><b>統計</b></div>
            <div id="statContent">まだシミュレーションしていません。</div>
          </div>

          <div class="stat" id="mappingBox">
            <div><b>対応（入口→出口）</b></div>
            <div id="mappingContent">-</div>
          </div>

          <div style="margin-top:8px">
            <div class="small"><b>凡例</b></div>
            <div id="legend"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   共通ユーティリティ（両モードで共有）
   ========================= */
const COLORS = ['#e6194b','#3cb44b','#4363d8','#f58231','#911eb4','#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff','#9A6324','#fffac8','#800000','#aaffc3','#808000','#ffd8b1','#000075','#808080','#ffffff'];
function reflect(dir, mirror){
  if(mirror===0) return dir;
  if(mirror===1) return [1,0,3,2][dir];
  if(mirror===2) return [3,2,1,0][dir];
  return dir;
}
function stepCell(r,c,dir){ return [[r-1,c],[r,c+1],[r+1,c],[r,c-1]][dir]; }
const cfgToKey = cfg => cfg.join(',');

/* =========================
   探索モード (Explorer)
   名前空間： EXP
   ========================= */
const EXP = (function(){
  // DOM
  const sizeInput = document.getElementById('exp_sizeInput');
  const inputSelect = document.getElementById('exp_inputSelect');
  const runBtn = document.getElementById('exp_runBtn');
  const modeSelect = document.getElementById('exp_modeSelect');
  const samplesInput = document.getElementById('exp_samplesInput');
  const depthInput = document.getElementById('exp_depthInput');
  const forceExact = document.getElementById('exp_forceExact');
  const resultSummary = document.getElementById('exp_resultSummary');
  const canvasWrap = document.getElementById('exp_canvasWrap');
  const thumbs = document.getElementById('exp_thumbs');
  const progressSpan = document.getElementById('exp_progress');

  // simulate is slightly different name to avoid conflicts
  function simulate_local(N, mirrorConfig, startInput){
    let r=N-1, c=startInput, dir=0; const path=[];
    const MAX_STEPS = 10000;
    for(let steps=0; steps<MAX_STEPS; steps++){
      if(r<0||r>=N||c<0||c>=N){
        if(c===N && r>=0 && r<N) return {exited:true, exitSide:'R', exitRow:r, path};
        return {exited:false, exitSide:'other', exitRow:null, path};
      }
      path.push([r,c]);
      const idx = r*N + c;
      dir = reflect(dir, mirrorConfig[idx]);
      [r,c] = stepCell(r,c,dir);
    }
    return {exited:false, exitSide:'other', exitRow:null, path};
  }

  function canonicalizeConfig(N, cfg, path){
    const newCfg = cfg.slice();
    const visited = new Set(path.map(([r,c])=> r+','+c));
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(!visited.has(r+','+c)) newCfg[r*N+c]=0;
    return newCfg;
  }

  function fullEnumerate(N, startInput){
    const seen = new Map();
    let longest = 0, best = null;
    const total = Math.pow(3, N*N);
    for(let t=0; t<total; t++){
      let x=t;
      const cfg = new Array(N*N);
      for(let i=0;i<N*N;i++){ cfg[i] = x % 3; x = Math.floor(x/3); }
      const res = simulate_local(N, cfg, startInput);
      if(res.exited && res.exitSide === 'R'){
        const canon = canonicalizeConfig(N, cfg, res.path);
        const key = cfgToKey(canon);
        if(!seen.has(key)){
          seen.set(key, { cfg: canon, path: res.path.slice(), exitRow: res.exitRow });
          if(res.path.length > longest){
            longest = res.path.length;
            best = { cfg: canon.slice(), path: res.path.slice(), exitRow: res.exitRow };
          }
        }
      }
    }
    const patterns = [...seen.values()];
    if(best){
      const bestKey = cfgToKey(best.cfg);
      const idx = patterns.findIndex(p=>cfgToKey(p.cfg)===bestKey);
      if(idx>0){ const p = patterns.splice(idx,1)[0]; patterns.unshift(p); }
      else if(idx===-1) patterns.unshift(best);
    }
    return { count: seen.size, patterns, longest, totalConfigs: total };
  }

  async function approximateEnumerate(N, startInput, depthLimit, maxSamples, isHybrid, progressCb){
    if(N <= 3) {
      const res = fullEnumerate(N, startInput);
      if(progressCb) progressCb(1,1);
      return { estimatedCount: res.count, patterns: res.patterns, longest: res.longest, totalConfigs: res.totalConfigs };
    }
    const seen = new Map();
    let longest = 0, best = null;
    let current = new Array(N*N).fill(0);
    const keepLimit = Math.min(5000, Math.max(200, Math.floor(maxSamples * 0.002)));
    for(let s=0; s<maxSamples; s++){
      const cfg = isHybrid ? current.slice() : new Array(N*N).fill(0);
      for(let d=0; d<depthLimit; d++){
        cfg[Math.floor(Math.random()*N*N)] = Math.floor(Math.random()*3);
      }
      const res = simulate_local(N, cfg, startInput);
      if(res.exited && res.exitSide==='R'){
        const canon = canonicalizeConfig(N, cfg, res.path);
        const key = cfgToKey(canon);
        if(!seen.has(key)){
          if(seen.size < keepLimit){
            seen.set(key, { cfg: canon, path: res.path.length>200 ? res.path.slice(0,200) : res.path.slice(), exitRow: res.exitRow });
          } else if(Math.random() < 0.001){
            const keys = Array.from(seen.keys());
            const rem = keys[Math.floor(Math.random()*keys.length)];
            seen.delete(rem);
            seen.set(key, { cfg: canon, path: res.path.length>200 ? res.path.slice(0,200) : res.path.slice(), exitRow: res.exitRow });
          }
        }
        if(res.path.length > longest){
          longest = res.path.length;
          best = { cfg: canon.slice(), path: res.path.slice(), exitRow: res.exitRow };
          if(isHybrid) current = canon.slice();
        }
      }
      if(progressCb && s % Math.max(1, Math.floor(maxSamples/100)) === 0){
        progressCb(s+1, maxSamples);
      }
      if(s % 2000 === 0) await new Promise(r=>setTimeout(r,0));
    }
    if(progressCb) progressCb(maxSamples, maxSamples);
    const total = Math.pow(3, N*N);
    const estimatedCount = Math.round(total * (seen.size / Math.max(1, maxSamples)));
    const patterns = [...seen.values()];
    if(best){
      const bestKey = cfgToKey(best.cfg);
      const idx = patterns.findIndex(p=>cfgToKey(p.cfg)===bestKey);
      if(idx>0){ const p = patterns.splice(idx,1)[0]; patterns.unshift(p); }
      else if(idx===-1) patterns.unshift(best);
    }
    return { estimatedCount, patterns, longest, totalConfigs: total };
  }

  // UI helpers (drawer for grids)
  function drawGrid(N, cfg, path){
    canvasWrap.innerHTML = '';
    const svgNS='http://www.w3.org/2000/svg';
    const cell = 60, w = cell*N + 120, h = cell*N + 40;
    const svg = document.createElementNS(svgNS,'svg');
    svg.setAttribute('width', w); svg.setAttribute('height', h);
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      const x = c*cell+20, y = r*cell+20;
      const rect = document.createElementNS(svgNS,'rect');
      rect.setAttribute('x', x); rect.setAttribute('y', y); rect.setAttribute('width', cell); rect.setAttribute('height', cell);
      rect.setAttribute('fill','white'); rect.setAttribute('stroke','#ccc'); svg.appendChild(rect);
      const m = cfg[r*N+c];
      if(m===1||m===2){
        const line = document.createElementNS(svgNS,'line');
        if(m===1){ line.setAttribute('x1', x+cell-6); line.setAttribute('y1', y+6); line.setAttribute('x2', x+6); line.setAttribute('y2', y+cell-6); }
        else { line.setAttribute('x1', x+6); line.setAttribute('y1', y+6); line.setAttribute('x2', x+cell-6); line.setAttribute('y2', y+cell-6); }
        line.setAttribute('stroke','#222'); line.setAttribute('stroke-width',3); svg.appendChild(line);
      }
    }
    if(path && path.length>0){
      const pts = path.map(([r,c]) => (c*cell+20+cell/2)+','+(r*cell+20+cell/2)).join(' ');
      const pl = document.createElementNS(svgNS,'polyline');
      pl.setAttribute('points', pts); pl.setAttribute('fill','none'); pl.setAttribute('stroke','#d33'); pl.setAttribute('stroke-width','4');
      pl.setAttribute('stroke-linecap','round'); pl.setAttribute('stroke-linejoin','round'); svg.appendChild(pl);
    }
    canvasWrap.appendChild(svg);
  }

  // run handler
  runBtn.addEventListener('click', async ()=>{
    const N = parseInt(sizeInput.value,10);
    const mode = modeSelect.value;
    const inputVal = inputSelect.value;
    const maxSamples = parseInt(samplesInput.value,10);
    const depthLimit = parseInt(depthInput.value,10);
    const isHybrid = (mode==='hybrid');
    const preferExact = forceExact.checked;
    const autoExact = N <= 3;
    const doExact = preferExact || autoExact;

    thumbs.innerHTML=''; canvasWrap.innerHTML=''; progressSpan.textContent='';

    const totalConfigs = Math.pow(3, N*N);
    if(doExact && totalConfigs > 200000){
      if(!confirm(`完全探索を選択しています。\nN=${N} の全配置数は ${totalConfigs.toLocaleString()} です。\nブラウザで長時間かかる可能性があります。続行しますか？`)){
        resultSummary.textContent='キャンセルされました。';
        return;
      }
    }

    resultSummary.textContent = doExact ? '完全探索中...' : '探索中...';
    let combined = [], totalCount = 0, overallLongest = 0;
    const inputs = (inputVal === 'all') ? [...Array(N).keys()] : [parseInt(inputVal,10)];

    for(let sIdx=0; sIdx<inputs.length; sIdx++){
      const s = inputs[sIdx];
      progressSpan.textContent = `入力 ${s+1} を計算中...`;
      let res;
      if(doExact){
        res = fullEnumerate(N, s);
        totalCount += res.count;
      } else {
        res = await approximateEnumerate(N, s, depthLimit, maxSamples, isHybrid, (done, total)=> {
          progressSpan.textContent = `入力 ${s+1}: ${done}/${total} サンプル`;
        });
        totalCount += (res.estimatedCount ?? 0);
      }
      if(res.longest > overallLongest) overallLongest = res.longest ?? 0;
      res.patterns.forEach(p => combined.push(Object.assign({inputIndex: s}, p)));
    }

    progressSpan.textContent = '';
    resultSummary.innerHTML = `<b>${ inputVal === 'all' ? '全体' : '個別' }（${doExact ? '完全探索' : '近似'}）</b><br>` +
      (doExact ? `有効パターン数（正確）: ${totalCount}` : `推定有効パターン数: 約${totalCount}`) +
      `<br>発見された最長経路マス数: ${overallLongest}`;

    const uniqMap = new Map();
    combined.forEach(p => {
      const k = cfgToKey(p.cfg);
      if(!uniqMap.has(k)) uniqMap.set(k, p);
    });
    const patterns = Array.from(uniqMap.values());
    renderThumbs(patterns, N);
  });

  // input options
  function updateInputOptions(){
    const N = parseInt(sizeInput.value,10);
    inputSelect.innerHTML='';
    const optAll = document.createElement('option'); optAll.value='all'; optAll.textContent='全体'; inputSelect.appendChild(optAll);
    for(let i=0;i<N;i++){ const o=document.createElement('option'); o.value=i; o.textContent='入力 '+(i+1); inputSelect.appendChild(o); }
  }
  updateInputOptions();
  sizeInput.addEventListener('change', updateInputOptions);

  // thumbnails
  function renderThumbs(patterns, N){
    thumbs.innerHTML='';
    if(!patterns || patterns.length===0){ thumbs.textContent='有効なパターンはありません。'; return; }
    const uniq = new Map();
    patterns.forEach(p => { uniq.set(cfgToKey(p.cfg), p); });
    const list = Array.from(uniq.values());
    const maxLen = Math.max(...list.map(p=>p.path.length));
    const longestIndex = list.findIndex(p=>p.path.length===maxLen);
    if(longestIndex > 0){ const [lp] = list.splice(longestIndex,1); list.unshift(lp); }
    const showCount = Math.min(200, list.length);
    const finalList = list.slice(0, showCount);
    let i=0; const batchSize=8; const startTime = performance.now(); const maxAllowed=2000;
    async function drawBatch(){
      for(let b=0; b<batchSize && i<finalList.length; b++, i++){
        const item = finalList[i];
        const div = document.createElement('div'); div.className='thumb';
        const canvas = document.createElement('canvas'); canvas.width=120; canvas.height=120; div.appendChild(canvas);
        const info = document.createElement('div'); info.className='small';
        info.textContent = `入 ${ (item.inputIndex!=null ? (item.inputIndex+1)+' → ' : '') }出 ${String.fromCharCode(65 + (item.exitRow ?? 0))} / ${item.path.length}${item.path.length===maxLen ? ' ⭐最長' : ''}`;
        div.appendChild(info);
        thumbs.appendChild(div);
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,120,120);
        ctx.strokeStyle = '#ccc'; ctx.lineWidth=0.6;
        const cell = 120 / Math.max(1,N);
        for(let r=0;r<N;r++) for(let c=0;c<N;c++){
          const m = item.cfg[r*N+c];
          if(m===1||m===2){
            ctx.beginPath();
            if(m===1){ ctx.moveTo((c+1)*cell-2, r*cell+2); ctx.lineTo(c*cell+2, (r+1)*cell-2); }
            else { ctx.moveTo(c*cell+2, r*cell+2); ctx.lineTo((c+1)*cell-2, (r+1)*cell-2); }
            ctx.stroke();
          }
        }
        ctx.strokeStyle='#d33'; ctx.lineWidth=1.4; ctx.beginPath();
        const step = Math.max(1, Math.floor(item.path.length / 200));
        let moved=false;
        item.path.forEach(([r,c], idx)=>{ if(idx%step!==0) return; const x=c*cell+cell/2, y=r*cell+cell/2; if(!moved){ctx.moveTo(x,y); moved=true;} else ctx.lineTo(x,y); });
        ctx.stroke();
        div.addEventListener('click', ()=> drawGrid(N, item.cfg, item.path));
      }
      if(performance.now() - startTime > maxAllowed){
        thumbs.innerHTML = '💡 描画負荷が高いため、最長経路のみを表示します。';
        const first = finalList[0];
        if(first) drawGrid(N, first.cfg, first.path);
        return;
      }
      if(i < finalList.length){
        await new Promise(r=>setTimeout(r,12));
        requestAnimationFrame(drawBatch);
      } else {
        const first = finalList[0];
        if(first) drawGrid(N, first.cfg, first.path);
      }
    }
    drawBatch();
  }

  // export API for use by outer scope if needed
  return {
    simulate_local,
    fullEnumerate,
    approximateEnumerate
  };
})();

/* =========================
   サンドボックスモード (Sandbox)
   名前空間： SB
   ========================= */
const SB = (function(){
  // DOM references (sandbox-specific)
  const sizeInput = document.getElementById('sb_sizeInput');
  const simMode = document.getElementById('sb_simMode');
  const simulateBtn = document.getElementById('sb_simulateBtn');
  const resetBtn = document.getElementById('sb_resetBtn');
  const boardWrap = document.getElementById('boardWrap');
  const statsBox = document.getElementById('statContent');
  const mappingContent = document.getElementById('mappingContent');
  const legendDiv = document.getElementById('legend');

  // state
  let N = 5, cfg = [], inputsBottom = [], inputsLeft = [];

  function simulateSingle(N,cfg,startR,startC,startDir){
    let r=startR, c=startC, dir=startDir;
    const path = [];
    const MAX_STEPS = 10000;
    for(let i=0;i<MAX_STEPS;i++){
      if(r<0||r>=N||c<0||c>=N){
        if(c===N) return {exited:true, exitSide:'R', exitIndex:r, path};
        if(c===-1) return {exited:true, exitSide:'L', exitIndex:r, path};
        if(r===-1) return {exited:true, exitSide:'U', exitIndex:c, path};
        if(r===N) return {exited:true, exitSide:'D', exitIndex:c, path};
        return {exited:false, path};
      }
      path.push([r,c]);
      const idx = r*N + c;
      dir = reflect(dir, cfg[idx]);
      [r,c] = stepCell(r,c,dir);
    }
    return {exited:false, path};
  }

  function initState(){
    N = Math.max(1, parseInt(sizeInput.value) || 5);
    cfg = new Array(N*N).fill(0);
    inputsBottom = new Array(N).fill(false);
    inputsLeft = new Array(N).fill(false);
    renderBoard();
    renderLegend();
    statsBox.textContent = 'まだシミュレーションしていません。';
    mappingContent.textContent = '-';
  }
  sizeInput.addEventListener('input', ()=> initState());

  function renderLegend(){
    legendDiv.innerHTML = '';
    const count = Math.max(1, Math.min(N, COLORS.length));
    for(let i=0;i<count;i++){
      const div = document.createElement('div');
      div.className = 'legend-item';
      div.innerHTML = `<div class="swatch" style="background:${COLORS[i]}"></div>光${String.fromCharCode(65+i)}`;
      legendDiv.appendChild(div);
    }
  }

  function renderBoard(){
    boardWrap.innerHTML = '';
    const svgNS = 'http://www.w3.org/2000/svg';
    const CELL = 48;
    const MARGIN = 60;
    const w = CELL * N + MARGIN * 2;
    const h = CELL * N + MARGIN * 2;
    const svg = document.createElementNS(svgNS,'svg');
    svg.setAttribute('width', w);
    svg.setAttribute('height', h);
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);

    // grid cells
    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const x = c*CELL + MARGIN;
        const y = r*CELL + MARGIN;
        const rect = document.createElementNS(svgNS,'rect');
        rect.setAttribute('x', x); rect.setAttribute('y', y);
        rect.setAttribute('width', CELL); rect.setAttribute('height', CELL);
        rect.setAttribute('fill', '#fff'); rect.setAttribute('stroke', '#ccc');
        svg.appendChild(rect);
        const m = cfg[r*N + c];
        if(m){
          const line = document.createElementNS(svgNS,'line');
          if(m === 1){
            line.setAttribute('x1', x + CELL - 6); line.setAttribute('y1', y + 6);
            line.setAttribute('x2', x + 6); line.setAttribute('y2', y + CELL - 6);
          } else {
            line.setAttribute('x1', x + 6); line.setAttribute('y1', y + 6);
            line.setAttribute('x2', x + CELL - 6); line.setAttribute('y2', y + CELL - 6);
          }
          line.setAttribute('stroke', '#222'); line.setAttribute('stroke-width', 3); svg.appendChild(line);
        }
      }
    }

    // bottom markers
    for(let c=0;c<N;c++){
      const cx = MARGIN + c*CELL + CELL/2;
      const cy = MARGIN + N*CELL + 20;
      const circle = document.createElementNS(svgNS,'circle');
      circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
      circle.setAttribute('r', 8);
      circle.setAttribute('fill', inputsBottom[c] ? '#222' : '#fff');
      circle.setAttribute('stroke', '#222');
      circle.dataset.bottom = c; circle.style.cursor = 'pointer'; svg.appendChild(circle);
      if(inputsBottom[c]){
        const t = document.createElementNS(svgNS,'text');
        t.textContent = String.fromCharCode(65 + c);
        t.setAttribute('x', cx); t.setAttribute('y', cy + 22);
        t.setAttribute('text-anchor', 'middle');
        t.setAttribute('font-size', 15); t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', '#000'); svg.appendChild(t);
      }
    }

    // left markers
    for(let r=0;r<N;r++){
      const cx = MARGIN - 20;
      const cy = MARGIN + r*CELL + CELL/2;
      const circle = document.createElementNS(svgNS,'circle');
      circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
      circle.setAttribute('r', 8);
      circle.setAttribute('fill', inputsLeft[r] ? '#222' : '#fff');
      circle.setAttribute('stroke', '#222');
      circle.dataset.left = r; circle.style.cursor = 'pointer'; svg.appendChild(circle);
      if(inputsLeft[r]){
        const t = document.createElementNS(svgNS,'text');
        t.textContent = String.fromCharCode(65 + r);
        t.setAttribute('x', cx - 22); t.setAttribute('y', cy + 5);
        t.setAttribute('text-anchor', 'middle');
        t.setAttribute('font-size', 15); t.setAttribute('font-weight', 'bold');
        t.setAttribute('fill', '#000'); svg.appendChild(t);
      }
    }

    svg.addEventListener('click', ev => {
      const pt = svg.createSVGPoint(); pt.x = ev.clientX; pt.y = ev.clientY;
      const loc = pt.matrixTransform(svg.getScreenCTM().inverse());
      handleClick(loc.x, loc.y, svg);
    });

    boardWrap.appendChild(svg);
  }

  function handleClick(x,y,svg){
    const CELL = 48;
    const MARGIN = 60;
    // bottom markers
    for(const el of svg.querySelectorAll('circle[data-bottom]')){
      const cx = parseFloat(el.getAttribute('cx')), cy = parseFloat(el.getAttribute('cy'));
      if(Math.hypot(cx-x, cy-y) <= 10){ const c = parseInt(el.dataset.bottom, 10); inputsBottom[c] = !inputsBottom[c]; renderBoard(); return; }
    }
    // left markers
    for(const el of svg.querySelectorAll('circle[data-left]')){
      const cx = parseFloat(el.getAttribute('cx')), cy = parseFloat(el.getAttribute('cy'));
      if(Math.hypot(cx-x, cy-y) <= 10){ const r = parseInt(el.dataset.left, 10); inputsLeft[r] = !inputsLeft[r]; renderBoard(); return; }
    }
    // cells
    const gx = x - MARGIN, gy = y - MARGIN;
    const c = Math.floor(gx / CELL), r = Math.floor(gy / CELL);
    if(r >= 0 && r < N && c >= 0 && c < N){ cfg[r*N + c] = (cfg[r*N + c] + 1) % 3; renderBoard(); }
  }

  function simulateMultiByMode(mode){
    const results = [];
    const upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const lower = upper.toLowerCase();
    if(mode === 'down' || mode === 'both'){
      for(let c=0;c<N;c++) if(inputsBottom[c]) results.push({ type:'down', index:c, letter: upper[c] || ('?'+c), res: simulateSingle(N, cfg, N-1, c, 0) });
    }
    if(mode === 'left' || mode === 'both'){
      for(let r=0;r<N;r++) if(inputsLeft[r]) results.push({ type:'left', index:r, letter: lower[r] || ('?'+r), res: simulateSingle(N, cfg, r, 0, 1) });
    }
    return results;
  }

  function drawSimulation(results){
    const svg = boardWrap.querySelector('svg'); if(!svg) return;
    svg.querySelectorAll('[data-overlay]').forEach(e => e.remove());
    const CELL = 48;
    const MARGIN = 60;
    for(let i=0;i<results.length;i++){
      const entry = results[i];
      const res = entry.res;
      const color = COLORS[i % COLORS.length];
      if(res.path && res.path.length > 0){
        const pts = res.path.map(([r,c]) => `${MARGIN + c*CELL + CELL/2},${MARGIN + r*CELL + CELL/2}`).join(' ');
        const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
        poly.setAttribute('points', pts); poly.setAttribute('fill', 'none'); poly.setAttribute('stroke', color);
        poly.setAttribute('stroke-width', 3); poly.setAttribute('stroke-linecap', 'round'); poly.setAttribute('data-overlay', '1'); svg.appendChild(poly);

        if(res.exited){
          let exx, exy; const gap = 18;
          if(res.exitSide === 'R'){ exx = MARGIN + N*CELL + gap; exy = MARGIN + res.exitIndex*CELL + CELL/2; }
          if(res.exitSide === 'U'){ exx = MARGIN + res.exitIndex*CELL + CELL/2; exy = MARGIN - gap; }
          if(res.exitSide === 'L'){ exx = MARGIN - gap; exy = MARGIN + res.exitIndex*CELL + CELL/2; }
          if(res.exitSide === 'D'){ exx = MARGIN + res.exitIndex*CELL + CELL/2; exy = MARGIN + N*CELL + gap; }

          const et = document.createElementNS('http://www.w3.org/2000/svg','text');
          et.textContent = entry.letter;
          et.setAttribute('x', exx); et.setAttribute('y', exy);
          et.setAttribute('font-size', 18); et.setAttribute('font-weight', 'bold');
          et.setAttribute('fill', '#000'); et.setAttribute('stroke', '#fff'); et.setAttribute('stroke-width', 3);
          et.setAttribute('paint-order', 'stroke'); et.setAttribute('text-anchor', 'middle'); et.setAttribute('dominant-baseline', 'middle');
          et.setAttribute('data-overlay', '1'); svg.appendChild(et);
        }
      }
    }
    updateStatsAndMapping(results);
  }

  function updateStatsAndMapping(results){
    if(!results || results.length === 0){ statsBox.textContent = 'まだシミュレーションしていません。'; mappingContent.textContent = '-'; return; }
    let exitCount = 0; let total = 0; let html = '', map = '';
    results.forEach(r => {
      const len = r.res.path.length; total += len; if(r.res.exited) exitCount++;
      html += `${r.letter}: len=${len} / ${r.res.exited ? ('exit=' + r.res.exitSide + '(' + r.res.exitIndex + ')') : '未到達'}<br>`;
      map += `<div class="small">${r.letter} → ${r.res.exited ? (r.res.exitSide + ' ' + r.res.exitIndex) : '未到達'}</div>`;
    });
    statsBox.innerHTML = `・光線本数: ${results.length}<br>・通過マス数: ${total}<br>・出口数: ${exitCount}<br><b>各光線</b><br>${html}`;
    mappingContent.innerHTML = map;
  }

  simulateBtn.addEventListener('click', ()=>{
    const results = simulateMultiByMode(simMode.value);
    drawSimulation(results);
  });
  resetBtn.addEventListener('click', ()=>{ if(confirm('盤面を初期化しますか？')) initState(); });

  // init
  initState();

  // expose simulate for external use if needed
  return {
    simulateSingle
  };
})();

/* =========================
   タブ切替ロジック
   ========================= */
(function(){
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach(t => t.addEventListener('click', ()=>{
    tabs.forEach(x=>x.classList.remove('active'));
    t.classList.add('active');
    const tgt = t.dataset.target;
    document.querySelectorAll('.section').forEach(s=>s.classList.remove('active'));
    document.getElementById(tgt).classList.add('active');
    // optional: when switching to sandbox, trigger a render in case size changed externally
    if(tgt === 'sandbox'){ /* SB already manages its own rendering */ }
    if(tgt === 'explorer'){ /* EXP manages its own UI */ }
  }));
})();
</script>
</body>
</html>
